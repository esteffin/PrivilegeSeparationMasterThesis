%{
open System
open Utils.ParsingUtils
open LambdaJS.PreParsing
open LambdaJS.Syntax

type N = LambdaJS.Syntax.Expr
type E = LambdaJS.Syntax.EExpr

let (!.) id = id, id

let btw = location.Between
let r = List.rev

%}

// The start token becomes a parser function in the compiled code:
%start start

// These are the terminal tokens of the grammar along with the types of
// the data carried by each token:
%token <location> 
    NPLUS SPLUS MUL DIV MOD SUB LT SLT SEQ AEQ TYPEOF SURF_TYPEOF
    PRIM_TO_NUM PRIM_TO_STR PRIM_TO_BOOL IS_PRIM TO_INT TO_INT32 TO_UINT32
    BAND BOR BXOR BNOT SHL SHR ZFSHR HAS_OWN_PROP PRINT SCONTAINS
    ITER_HAS_NEXT ITER_NEXT ITER_KEY STARTS_WITH SLENGTH SSPLIT_REGEXP SSPLIT_STREXP
    CAN_DELETE EXP LOG COS SIN ABS POW PREGEXP_QUOTE REGEXP_MATCH
    // Numerical constants
    NAN PINF MINF 
    // Bool 
    TRUE FALSE 
    // Constants
    UNDEFINED NULL 
    // Keywords
    LAMBDA OBJECT IF LABEL BREAK BEGIN LET THROW TRY_CATCH TRY_FINALLY
    ALLOC DEREF GET_FIELD SET EVAL_SEMANTIC_BOMB UPDATE_FIELD DELETE_FIELD WHILE 
    // Misc
    BRA KET 

%token <float * location> FLOAT
%token <int * location> INT32 
%token <string * location>  STRING ID TMP_VAR GLOBAL_VAR AT_CALL

%token EOF

// This is the type of the data produced by a successful reduction of the 'start'
// symbol:
%type < LambdaJS.Syntax.Program > start

%%

// These are the rules of the grammar along with the F# code of the 
// actions executed as rules are reduced.  In this case the actions 
// produce data using F# data construction terms.
start: 
    Program			            { $1 }

// Literals    
num:
| INT32                     { let (n, loc) = $1 in N(E.ENumber(float n), loc) }
| FLOAT                     { let (n, loc) = $1 in N(E.ENumber n, loc) }
| NAN                       { N (E.ENumber System.Double.NaN, $1) }
| PINF                      { N (E.ENumber System.Double.PositiveInfinity, $1) }
| MINF                      { N (E.ENumber System.Double.NegativeInfinity, $1) }

bool: 
| TRUE                      { N (E.EBool true, $1) }
| FALSE                     { N (E.EBool false, $1) }

exprs: 
| Expr                      { [$1] }
| Expr exprs                { $1::$2 }

// Localized id
lid:
| ID                        { $1 }
| TMP_VAR                   { $1 }
| GLOBAL_VAR                { $1 }
| AT_CALL                   { $1 }

id:
| lid                       { let id, _ = $1 in !.id }

ids:
| id                        { [$1] }
| id ids                    { $1::$2 }

props:
| BRA STRING Expr KET       { let (s, _) = $2 in [(s, $3)] }
| BRA STRING Expr KET props { let (s, _) = $2 in (s, $3)::$5 }

binds:
| bind                      { [$1] }
| bind binds                { $1::$2 }

bind:
| BRA id Expr KET           { ($2, $3) }

Program: 
| Expr EOF                  { P $1 }

Expr: 
| num                                 { $1 }
| STRING                              { let (s, loc) = $1 in N (E.EString s, loc) }
| bool                                { $1 }
| UNDEFINED                           { N (E.EUndefined, $1) }
| NULL                                { N (E.ENull, $1) }
| BRA LAMBDA BRA KET Expr KET         { N (E.ELambda ([], $5), btw $1 $6) }
| BRA LAMBDA BRA ids KET Expr KET     { N (E.ELambda (r $4, $6), btw $1 $7) }
| BRA OBJECT KET                      { N (E.EObject [], btw $1 $3) }
| BRA OBJECT props KET                { N (E.EObject (r $3), btw $1 $4) }
| lid                                 { let id, l = $1 in N (E.EId !.id, l) }
| BRA Op exprs KET                    { N (E.EOp ($2, r $3), btw $1 $4) }
| BRA Expr KET                        { N (E.EApp ($2, []), btw $1 $3) }
| BRA Expr exprs KET                  { N (E.EApp ($2, r $3), btw $1 $4) }
| BRA LET BRA KET Expr KET            { N (E.ELet ([], $5), btw $1 $6) }
| BRA LET BRA binds KET Expr KET      { N (E.ELet (r $4, $6), btw $1 $7) }
| BRA SET Expr Expr KET               { N (E.ESetRef ($3, $4), btw $1 $5) }
| BRA ALLOC Expr KET                  { N (E.ERef $3, btw $1 $4) }
| BRA DEREF Expr KET                  { N (E.EDeref $3, btw $1 $4) }
| BRA GET_FIELD Expr Expr KET         { N (E.EGetField ($3, $4), btw $1 $5) }
| BRA UPDATE_FIELD Expr Expr Expr KET { N (E.EUpdateField ($3, $4, $5), btw $1 $6) }
| BRA DELETE_FIELD Expr Expr KET      { N (E.EDeleteField ($3, $4), btw $1 $5) }
| BRA BEGIN Expr Expr KET             { N (E.ESeq ($3, $4), btw $1 $5) }
| BRA IF Expr Expr Expr KET           { N (E.EIf ($3, $4, $5), btw $1 $6) }
| BRA WHILE Expr Expr KET             { N (E.EWhile ($3, $4), btw $1 $5) }
| BRA LABEL id Expr KET               { N (E.ELabel ($3, $4), btw $1 $5) }
| BRA BREAK id Expr KET               { N (E.EBreak ($3, $4), btw $1 $5) }
| BRA THROW Expr KET                  { N (E.EThrow $3, btw $1 $4) }
| BRA TRY_CATCH Expr Expr KET         { N (E.ECatch ($3, $4), btw $1 $5) }
| BRA TRY_FINALLY Expr Expr KET       { N (E.EFinally ($3, $4), btw $1 $5) }
| EVAL_SEMANTIC_BOMB                  { N (E.EEval, btw $1 $1) }

Op:
| NPLUS             { Op.ONumPlus }
| SPLUS             { Op.OStrPlus }
| MUL               { Op.OMul }
| DIV               { Op.ODiv }
| MOD               { Op.OMod }
| SUB               { Op.OSub }
| LT                { Op.OLt }
| SLT               { Op.OStrLt }
| SEQ               { Op.OStrictEq }
| AEQ               { Op.OAbstractEq }
| TYPEOF            { Op.OTypeof }
| SURF_TYPEOF       { Op.OSurfaceTypeof }
| PRIM_TO_NUM       { Op.OPrimToNum }
| PRIM_TO_STR       { Op.OPrimToStr }
| PRIM_TO_BOOL      { Op.OPrimToBool }
| IS_PRIM           { Op.OIsPrim }
| TO_INT            { Op.OToInteger }
| TO_INT32          { Op.OToInt32 }
| TO_UINT32         { Op.OToUInt32 }
| BAND              { Op.OBAnd }
| BOR               { Op.OBOr }
| BXOR              { Op.OBXOr }
| BNOT              { Op.OBNot }
| SHL               { Op.OLShift }
| SHR               { Op.ORShift }
| ZFSHR             { Op.OZfRShift }
| HAS_OWN_PROP      { Op.OHasOwnProp }
| PRINT             { Op.OPrint }
| SCONTAINS         { Op.OStrContains }
| ITER_HAS_NEXT     { Op.OObjIterHasNext }
| ITER_NEXT         { Op.OObjIterNext }
| ITER_KEY          { Op.OObjIterKey }
| STARTS_WITH       { Op.OStrStartsWith }
| SLENGTH           { Op.OStrLen }
| SSPLIT_REGEXP     { Op.OStrSplitRegExp }
| SSPLIT_STREXP     { Op.OStrSplitStrExp }
| CAN_DELETE        { Op.OObjCanDelete }
| EXP               { Op.OMathExp }
| LOG               { Op.OMathLog }
| COS               { Op.OMathCos }
| SIN               { Op.OMathSin }
| ABS               { Op.OMathAbs }
| POW               { Op.OMathPow }
| PREGEXP_QUOTE     { Op.ORegExpQuote }
| REGEXP_MATCH      { Op.ORegExpMatch }

