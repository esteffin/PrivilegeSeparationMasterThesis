In this chapter we will show how the calculus and the analysis of chapter \ref{chap:Formalization} has been implemented. We developed a tool written in F\# that from a real chrome extension is able to detect which privileges ca be obtained by an attacker that infect a content script.

In order to apply the analysis we had to desugar the JavaScript sources in \ljs. To this purpose we use the desugarer prototype that is a tool written in Haskell and described in \cite{LambdaJS}. Then we parse the desugared \ljs\ file and we start the analysis.

Since we are using the 0-CFA approach for the analysis, we do not have any context, so to enhance the precision of the analysis (soundness is kept) we alpha-rename the bound variables in order to distinguish them. We also mark the nodes of the abstract syntax tree with unambiguous labels and we annotate references with $\ell$. After that the AST is passed to the algorithm that generates the constraints producing a set of constraints. After that, given an abstract value representation, the constraint are resolved without using the AST any more producing an estimate for the initial program.
Finally analyzing the estimate we show the permission that an attacker can escalate if it infect a content script.


\section{Analysis specification}
\label{sec:AnalysisSpec}
As explained in section \ref{sec:FlowLogic} the flow logic can be done using various approaches. In the analysis of section \ref{sec:Analysis} it is used an abstract succinct approach, but for the implementation of the analysis it is needed a compositional verbose one. The difference between abstract and compositional approach are that the former is closer to the semantic and tend to be simpler, while the latter is more syntax directed. Moreover the abstract approach lets the analysis of lambdas in the application point, while the other analyze it at definition point. The function call in the compositional approach just link the arguments to the formal parameters of the lambda, and links the result of the lambda to the value of the call node.

The differences between a succinct and a verbose analysis are that the succinct analysis focus on the top-level part of the analysis estimate, while the verbose, as in data flow analysis and constraint based analysis, reports all the internal flow data. This second approach is done using caches that holds the analysis informations. 

In the following sections we translate the analysis of section \ref{sec:Analysis} to a compositional verbose one and then we transform the judgments to a set of constraints.

\begin{comment}
\subsection{Abstract succinct}
\[
\begin{array}{llcl}
\mathit{Abstract\ cache} & \Cat & : & \labs \rightarrow \absvalues \\
\mathit{Abstract\ variable\ environment} & \Env & : & \vars \rightarrow \absvalues \\
\mathit{Abstract\ memory} & \absmem & : & \labs \times \perms \rightarrow \absvalues \\
\mathit{Abstract\ permission\ cache} & \Pat & : & \labs \rightarrow \perms \\
\end{array}
\]

\begin{tabular}{l l l l}
{[\textit{PV-Name}]}&\multicolumn{3}{l}{$\aenvs \modelrho n : \vat$ iff $n \in \vat$} \\
{[\textit{PV-Var}]}&\multicolumn{3}{l}{$\aenvs \modelrho x : \vat$ iff $\Env(x) \subseteq \vat$} \\ 
{[\textit{PV-Cons}]}&\multicolumn{3}{l}{$\aenvs \modelrho c : \vat$ iff $\{\hat{c}\} \subseteq \vat$} \\
{[\textit{PV-Ref}]}&\multicolumn{3}{l}{$\aenvs \modelrho \ell : \vat$ iff $\ell \in \vat$} \\
{[\textit{PV-Lambda}]}&\multicolumn{3}{l}{$\aenvs \modelrho \lam{x}{e} : \vat$ iff $\lambda_x^{\rho_e} \in \vat \wedge \aenvs \modelrho e : \vat'\gg \rho' $} \\
&&\multicolumn{2}{l}{$\vat' \sqsubseteq \Env(\lambda x) \wedge \rho' \sqsubseteq \rho_e $}\\
{[\textit{PV-Ref}]}&\multicolumn{3}{l}{$\aenvs \modelrho \rec{\vec{str_i : v_i}} : \vat$ iff $\{\absrec{\vec{str_i: v_i}}_{\absC,\rho}\} \sqsubseteq \hat{v}$} \\
\end{tabular}

\begin{table}[htb]
\begin{tabular}{l l l l}
{[\textit{PE-Val}]}&\multicolumn{3}{l}{$\caest {v}$ iff}\\
&&\multicolumn{2}{l}{$\aenvs \modelrho v : \vat$} \\
{[\textit{PE-Let}]}&\multicolumn{3}{l}{$\caest {\letexpr{x}{e_1}{e_2}}$ iff}\\
&&\multicolumn{2}{l}{$\caesti {e_1} {1} \wedge \vat_1 \sqsubseteq \Env(x) \wedge \rho_1 \sqsubseteq \rho \wedge$} \\
&&\multicolumn{2}{l}{$\aenvs \modelrho e_2 : \vat_2 \gg \rho_2 \wedge \vat_2 \sqsubseteq \vat \wedge \rho_2 \sqsubseteq \rho$} \\
{[\textit{PE-App}]}&\multicolumn{3}{l}{$\caest {\appl {e_1} {e_2}}$ iff} \\
&&\multicolumn{2}{l}{$\caesti {e_1} {1} \wedge \rho_1 \sqsubseteq \rho \wedge$} \\
&&\multicolumn{2}{l}{$\caesti {e_2} {2} \wedge \rho_2 \sqsubseteq \rho \wedge$} \\
&&\multicolumn{2}{l}{$\forall \lambda x^{\rho_e} \in \vat_1 :$}\\
&&&$\vat_2 \subseteq \Env(x) \wedge$\\
&&&$\Env(\lambda x) \sqsubseteq \vat \wedge \rho_e \sqsubseteq \rho$\\ 
{[\textit{PE-Seq}]}&\multicolumn{3}{l}{$\caest {e_1; e_2} $ iff}\\
&&\multicolumn{2}{l}{$ \caesti {e_1} {1} \wedge \rho_1 \sqsubseteq \rho \wedge$}\\
&&\multicolumn{2}{l}{$ \caesti {e_2} {2} \wedge \rho_2 \sqsubseteq \rho \wedge$} \\
&&\multicolumn{2}{l}{$\vat_2 \sqsubseteq \vat$} \\
{[\textit{PE-Op}]}&\multicolumn{3}{l}{$\caest {\op (\vec{e_i})} $ iff}\\
&&\multicolumn{2}{l}{$\forall i :$}\\
&&&$\caesti {e_i} {i} \wedge \rho_i \sqsubseteq \rho \wedge$\\
&&\multicolumn{2}{l}{$\widehat{op} (\vec{\vat_i}) \sqsubseteq \vat $}\\
{[\textit{PE-Cond}]}&\multicolumn{3}{l}{$\caest {\cond {e_0} {e_1} {e_2}} $ iff}\\
&&\multicolumn{2}{l}{$\caesti {e_0} {0} \wedge \rho_0 \sqsubseteq \rho \wedge$}\\
&&\multicolumn{2}{l}{$\mathbf{\true} \in \vat_0 \Rightarrow$}\\
&&&$\caesti {e_1} {1} \wedge \vat_1 \sqsubseteq \vat \wedge \rho_1 \sqsubseteq \rho \wedge$ \\
&&\multicolumn{2}{l}{$\mathbf{\false} \in \vat_0 \Rightarrow$}\\
&&&$\caesti {e_2} {2} \wedge \vat_2 \sqsubseteq \vat \wedge \rho_2 \sqsubseteq \rho$ \\
{[\textit{PE-While}]}&\multicolumn{3}{l}{$\caest {\while {e_1} {e_2}} $ iff}\\
&&\multicolumn{2}{l}{$\caesti {e_1} {1} \wedge \rho_1 \sqsubseteq \rho \wedge$}\\
&&\multicolumn{2}{l}{$\mathbf{\true} \in \vat_1 \Rightarrow$}\\
&&&$\caesti {e_2} {2} \wedge \rho_2 \sqsubseteq \rho \wedge$\\ % opinabile rispetto a lambda js
&&\multicolumn{2}{l}{$\widehat{\false} \in \vat_1 \Rightarrow$}\\
&&&$\widehat{\undef} \sqsubseteq \vat$\\
\end{tabular}
\caption{Abstract succinct part 1.}
\label{tab:AbstSucc1}
\end{table}
\begin{table}[htb]
\begin{tabular} {l l l l}
{[\textit{PE-GetField}]}&\multicolumn{3}{l}{$\caest {\lookup {e_1} {e_2}} $ iff}\\
&&\multicolumn{2}{l}{$ \caesti {e_1} {1} \wedge \rho_1 \sqsubseteq \rho \wedge$}\\
&&\multicolumn{2}{l}{$ \caesti {e_2} {2} \wedge \rho_2 \sqsubseteq \rho \wedge$} \\
&&\multicolumn{2}{l}{$\widehat{get} (\vat_1, \vat_2) \sqsubseteq \vat$} \\
{[\textit{PE-SetField}]}&\multicolumn{3}{l}{$\caest {\store {e_0} {e_1} {e_2}} $ iff}\\
&&\multicolumn{2}{l}{$ \caesti {e_0} {0} \wedge \rho_0 \sqsubseteq \rho \wedge$}\\
&&\multicolumn{2}{l}{$ \caesti {e_1} {1} \wedge \rho_1 \sqsubseteq \rho \wedge$} \\
&&\multicolumn{2}{l}{$ \caesti {e_2} {2} \wedge \rho_2 \sqsubseteq \rho \wedge$} \\
&&\multicolumn{2}{l}{$\widehat{set} (\vat_0, \vat_1, \vat_2) \sqsubseteq \vat$} \\
{[\textit{PE-DelField}]}&\multicolumn{3}{l}{$\caest {\delete {e_1} {e_2}} $ iff}\\
&&\multicolumn{2}{l}{$ \caesti {e_1} {1} \wedge \rho_1 \sqsubseteq \rho \wedge$}\\
&&\multicolumn{2}{l}{$ \caesti {e_2} {2} \wedge \rho_2 \sqsubseteq \rho \wedge$} \\
&&\multicolumn{2}{l}{$\widehat{del} (\vat_1, \vat_2) \sqsubseteq \vat$}\\
{[\textit{PE-Ref}]}&\multicolumn{3}{l}{$ \caest {\newref {\ell} {e}}$ iff}\\
&&\multicolumn{2}{l}{$ \caesti {e} {1} \wedge \rho_1 \sqsubseteq \rho\wedge$}\\
&&\multicolumn{2}{l}{$\vat_1 \sqsubseteq \muat(\ell, \rho_s) \wedge $} \\
&&\multicolumn{2}{l}{$\ell \in \vat$} \\
{[\textit{PE-DeRef}]}&\multicolumn{3}{l}{$\caest {\deref {e}} $ iff}\\
&&\multicolumn{2}{l}{$\caesti {e} {1} \wedge \rho_1 \sqsubseteq \rho \wedge$}\\
&&\multicolumn{2}{l}{$\forall \ell \in \vat_1 : \muat(\ell, \rho_s) \sqsubseteq \vat$ }\\
{[\textit{PE-SetRef}]}&\multicolumn{3}{l}{$\caest {\setref {e_1} {e_2}} $ iff}\\
&&\multicolumn{2}{l}{$ \caesti {e} {1} \wedge \rho_1 \sqsubseteq \rho \wedge$}\\
&&\multicolumn{2}{l}{$ \caesti {e_2} {2} \wedge \rho_2 \sqsubseteq \rho \wedge$}\\
%&&\multicolumn{2}{l}{$\rho_2 \sqsubseteq \rho \wedge$}\\
&&\multicolumn{2}{l}{$\vat_2 \sqsubseteq \vat \wedge$}\\
&&\multicolumn{2}{l}{$\forall \ell \in \vat_1: \vat_2 \sqsubseteq \muat(\ell, \rho_s)$}\\
{[\textit{PE-Send}]}&\multicolumn{3}{l}{$\caesti {\send {e_1} {e_2} {\rho}} {0} $ iff}\\
&&\multicolumn{2}{l}{$ \caesti {e} {1} \wedge \rho_1 \sqsubseteq \rho_0 \wedge$}\\
&&\multicolumn{2}{l}{$ \caesti {e} {2} \wedge \rho_2 \sqsubseteq \rho_0 \wedge$}\\
&&\multicolumn{2}{l}{$ \forall m \in \vat_1 : \forall \rho_m \sqsupseteq \rho:$}\\
&&&$\hat{\Upsilon}(m, \rho_m) = (\rho_r, \rho_e)\wedge $\\
&&&$\rho_r \sqsubseteq \rho_s \Rightarrow \rho_e \sqsubseteq \rho_0 \wedge$\\
&&&$\vat_2 \sqsubseteq \hat{\Phi}(m, \rho_m) \wedge $\\
&&&$\mathbf{unit} \in \vat $\\
{[\textit{PE-Exercise}]}&\multicolumn{3}{l}{$\caesti {\exercise {\rho}} {1} $ iff}\\
&&\multicolumn{2}{l}{$ \rho \sqsubseteq \rho_s \Rightarrow \rho \sqsubseteq \rho_1 \wedge $}\\
&&\multicolumn{2}{l}{$ \mathbf{unit} \in \vat$}\\
\end{tabular}
\caption{Abstract succinct part 2.}
\label{tab:AbstSucc2}
\end{table}
\end{comment}

\newcommand{\all}[0]{\alpha}

\newcommand{\absCV}{\mathcal{CV}}
\newcommand{\cenvs}{\absCV}
\newcommand{\Cat}[0]{\absCV_{\hat{C}}}
\newcommand{\muat}[0]{\absCV_{\hat{\mu}}}
\newcommand{\Env}[0]{\absCV_{\hat{\Gamma}}}
\newcommand{\Pat}[0]{\absCV_{\hat{P}}}
\newcommand{\Phiat}[0]{\absCV_{\hat{\Phi}}}
\newcommand{\Upsat}[0]{\absCV_{\hat{\Upsilon}}}
\newcommand{\ccest}[1]{\cenvs \Vdash_{cv, \rho_s} #1}
\newcommand{\ccestl}[1]{\cenvs \Vdash_{cv, \rho_s} {(#1)}^{\alpha}}
\newcommand{\lbt}[1]{{e_#1}^{\alpha_#1}}

\subsection{Compositional Verbose}
In compositional verbose approach we add an unambiguous label $\all$ to all expression in the syntax and the result of each expression are stored in an abstract cache $\hat{C}$ that its a map from nodes to abstract values. Even the permissions of each expression are stored in caches $\hat{P}$.

To enhance readability we let $\absCV = \hat{C}, \hat{P}, \hat{\Gamma}, \hat{\mu},  \abstack, \absnet$ to be the the compositional verbose environment that is a six-tuple made of the following components:
\[
\begin{array}{llcl}
\mathit{Abstract\ cache} & \hat{C} & : & A \rightarrow \absvalues \\
\mathit{Permission\ cache} & \hat{P} & : & \perms \rightarrow \perms \\
\mathit{Abstract\ variable\ environment} & \hat{\Gamma} & : & \vars \rightarrow \absvalues \\
\mathit{Abstract\ memory} & \hat{\mu} & : & \labs \times \perms \rightarrow \absvalues \\
\mathit{Abstract\ stack} & \abstack & : & \names \times \perms \rightarrow \perms \times \perms \\
\mathit{Abstract\ network} & \absnet & : & \names \times \perms \rightarrow \absvalues.
\end{array}
\]

While $\hat{\Gamma}, \hat{\mu},  \abstack, \absnet$ are the same of the previous chapter, the abstract cache $\hat{C}$, and permission cache $\hat{P}$ are specific of the compositional approach.

Table \ref{tab:CompVerb1} \ref{tab:CompVerb2} contains the rules for the compositional verbose analysis. Note that are very similar to the abstract succinct except that the expression of the form $\absC \Vdash_\rho e : v \gg \rho$ do not produce $v$ and $\rho$, but analysis store them in the cache and became $\absCV \Vdash_{cv,\rho} (e^{\all_1})^\all$ so $\Cat(\all) = v$ and $\Pat(\all) = \rho$.

%\newcommand{\all}[0]{\alpha}
\begin{table}[htb]
\begin{tabular}{l l l l}
{[\textit{CV-Val}]}&\multicolumn{3}{l}{$ \ccestl {v} $ iff $\{\vat\} \sqsubseteq \Cat(\all)$} \\ 
{[\textit{CV-Lambda}]}&\multicolumn{3}{l}{$ \ccestl {\lam{x}{\lbt 0}} $ iff}\\
&&\multicolumn{2}{l}{$\{\lam{x}{\lbt 0}\} \sqsubseteq \Cat(\all) \wedge $}\\
&&\multicolumn{2}{l}{$ \ccest {\lbt 0}$}\\
{[\textit{CV-Let}]}&\multicolumn{3}{l}{$ \ccestl {\letexpr{x}{\lbt 1}{{e'}^{\all'}}}$ iff}\\
&&\multicolumn{2}{l}{$ \ccest {{e'}^{\all'}} \wedge$} \\
&&\multicolumn{2}{l}{$ \Pat(\all') \sqsubseteq \Pat(\all) \wedge$}\\
&&\multicolumn{2}{l}{$ \Cat(\all') \sqsubseteq \Cat(\all) \wedge$}\\
&&\multicolumn{2}{l}{$\ccest {{e_1}^{\all_1}} \wedge$}\\
&&\multicolumn{2}{l}{ $ \Cat(\all_1) \sqsubseteq \Env(x_1) \wedge$} \\
&&\multicolumn{2}{l}{ $ \Pat(\all_1) \sqsubseteq \Pat(\all) $ }\\
{[\textit{CV-App}]}&\multicolumn{3}{l}{$ \ccestl {\appl {\lbt 1} {\lbt 2}}$ iff}\\
&&\multicolumn{2}{l}{$\ccest {\lbt 1} \wedge \ccest {\lbt 2} \wedge$} \\
&&\multicolumn{2}{l}{$\Pat(\all_1) \sqsubseteq \Pat(\all) \wedge \Pat(\all_2) \sqsubseteq \Pat(\all)$} \\
&&\multicolumn{2}{l}{$\forall (\lam{x}{\lbt 0}) \in \Cat(\all_1) :$}\\
&&&$\Cat(\all_2) \sqsubseteq \Env(x) \wedge \Cat(\all_0) \sqsubseteq \Cat(\all) \wedge$\\
&&&$\Pat(\all_0) \sqsubseteq \Pat(\all) $\\
{[\textit{CV-Seq}]}&\multicolumn{3}{l}{$ \ccestl {\lbt 1;\lbt 2} $ iff } \\ 
&&\multicolumn{2}{l}{$\ccest {\lbt 1} \wedge\Pat(\all_1) \sqsubseteq \Pat(\all) \wedge$} \\
&&\multicolumn{2}{l}{$\ccest {\lbt 2}\wedge \Pat(\all_2) \sqsubseteq \Pat(\all) \wedge$} \\
&&\multicolumn{2}{l}{$\Cat(\all_0) \sqsubseteq \Cat(\all)$} \\
{[\textit{CV-Op}]}&\multicolumn{3}{l}{$ \ccestl {\op (\vec{\lbt i})} $ iff}\\
&&\multicolumn{2}{l}{$\widehat{op} (\Cat(\all_i)) \sqsubseteq \Cat(\all) \wedge$}\\
&&\multicolumn{2}{l}{$\forall i : \ccest {\lbt i} \wedge \Pat(\all_i) \sqsubseteq \Pat(\all)  $}\\
{[\textit{CV-Cond}]}&\multicolumn{3}{l}{$\ccestl{\cond {\lbt 0} {\lbt 1} {\lbt 2}} $ iff}\\
&&\multicolumn{2}{l}{$ \ccest {\lbt 0} \wedge $}\\
&&\multicolumn{2}{l}{$\Pat(\all_0) \sqsubseteq \Pat(\all) \wedge$} \\
&&\multicolumn{2}{l}{$\widehat{\true} \in \Cat(\all_0) \Rightarrow$}\\
&&&$\ccest {\lbt 1} \wedge \Cat(\all_1) \sqsubseteq \Cat(\all)\wedge$\\
&&&$\Pat(\all_1) \sqsubseteq \Pat(\all) \wedge$ \\
&&\multicolumn{2}{l}{$\widehat{\false} \in \Cat(\all_0) \Rightarrow$}\\
&&&$\ccest {\lbt 2} \wedge \Cat(\all_2) \sqsubseteq \Cat(\all) \wedge$\\
&&&$\Pat(\all_2) \sqsubseteq \Pat(\all)$ \\
{[\textit{CV-While}]}&\multicolumn{3}{l}{$\ccestl {\while {\lbt 1} {\lbt 2}} $ iff}\\
&&\multicolumn{2}{l}{$ \ccest {\lbt 1} \wedge \Pat(\all_1) \sqsubseteq \Pat(\all) \wedge$}\\
&&\multicolumn{2}{l}{$\widehat{\true} \in \Cat(\all_1) \Rightarrow$}\\
&&&$\ccest {\lbt 2} \wedge \Pat(\all_2) \sqsubseteq \Pat(\all)\wedge$\\
&&\multicolumn{2}{l}{$\widehat{\false} \in \Cat(\all_1) \Rightarrow \widehat{\undef} \sqsubseteq \Cat(\all)$}\\
\end{tabular}
\caption{Compositional Verbose part 1}
\label{tab:CompVerb1}
\end{table}

\begin{table}[htb]
\begin{tabular} {l l l l}
{[\textit{CV-GetField}]}&\multicolumn{3}{l}{$\ccestl {\lookup {\lbt 1} {\lbt 2}} $ iff}\\
&&\multicolumn{2}{l}{$ \ccest {\lbt1} \wedge \Pat(\all_1) \sqsubseteq \Pat(\all) \wedge$}\\
&&\multicolumn{2}{l}{$ \ccest {\lbt 2} \wedge \Pat(\all_2) \sqsubseteq \Pat(\all) \wedge$} \\
&&\multicolumn{2}{l}{$\widehat{get} (\Cat(\all_1), \Cat(\all_2)) \sqsubseteq \Cat(\all)$} \\
{[\textit{CV-SetField}]}&\multicolumn{3}{l}{$\ccestl {\store {\lbt 0} {\lbt 1} {\lbt 2}} $ iff}\\
&&\multicolumn{2}{l}{$ \ccest {\lbt 0} \wedge \Pat(\all_0) \sqsubseteq \Pat(\all) \wedge$}\\
&&\multicolumn{2}{l}{$ \ccest {\lbt 1} \wedge \Pat(\all_1) \sqsubseteq \Pat(\all) \wedge$} \\
&&\multicolumn{2}{l}{$ \ccest {\lbt 2} \wedge \Pat(\all_2) \sqsubseteq \Pat(\all) \wedge$} \\
&&\multicolumn{2}{l}{$\widehat{set} (\Cat(\all_0), \Cat(\all_1), \Cat(\all_2)) \sqsubseteq \Cat(\all)$} \\
{[\textit{CV-DelField}]}&\multicolumn{3}{l}{$\ccestl {\delete {\lbt 1} {\lbt 2}} $ iff}\\ 
&&\multicolumn{2}{l}{$ \ccest {\lbt 1} \wedge \Pat(\all_1) \sqsubseteq \Pat(\all) \wedge$}\\
&&\multicolumn{2}{l}{$ \ccest {\lbt 2} \wedge \Pat(\all_2) \sqsubseteq \Pat(\all) \wedge$} \\
&&\multicolumn{2}{l}{$\widehat{del} (\Cat(\all_1), \Cat(\all_2)) \sqsubseteq \Cat(\all)$}\\
{[\textit{CV-Ref}]}&\multicolumn{3}{l}{$ \ccestl {\newref {\ell} {\lbt 1}} $ iff}\\
&&\multicolumn{2}{l}{$\ccest {\lbt 1} \wedge \Pat(\all_1) \sqsubseteq \Pat(\all) \wedge$}\\
&&\multicolumn{2}{l}{$\ell \in \Cat(\all) \wedge \Cat(\all_1) \sqsubseteq \muat(\ell, \rho_s) $}\\
{[\textit{CV-DeRef}]}&\multicolumn{3}{l}{$\ccestl {\deref {\lbt 1}} $ iff}\\
&&\multicolumn{2}{l}{$ \ccest {\lbt 1}\wedge \Pat(\all_1) \sqsubseteq \Pat(\all) \wedge$}\\
&&\multicolumn{2}{l}{$\forall \ell \in \Cat(\all_1) :\muat(\ell, \rho_s) \sqsubseteq \Cat(\all)$} \\
{[\textit{CV-SetRef}]}&\multicolumn{3}{l}{$\ccestl {\setref {\lbt 1} {\lbt 2}} $ iff}\\
&&\multicolumn{2}{l}{$ \ccest {\lbt 1} \wedge \Pat(\all_1) \sqsubseteq \Pat(\all) \wedge $}\\
&&\multicolumn{2}{l}{$ \ccest {\lbt 2} \wedge \Pat(\all_2) \sqsubseteq \Pat(\all) \wedge $}\\
&&\multicolumn{2}{l}{$\Cat(\all_2) \sqsubseteq \Cat(\all) \wedge$} \\
&&\multicolumn{2}{l}{$ \forall \ell \in \Cat(\all_1) : \Cat(\all_2) \sqsubseteq \muat(\ell, \rho_s)$} \\
{[\textit{CV-Send}]}&\multicolumn{3}{l}{$\ccestl {\send {e_1} {e_2} {\rho}} $ iff}\\
&&\multicolumn{2}{l}{$ \ccest {e_1} \wedge \Pat(\all_1) \sqsubseteq \Pat(\all) \wedge$}\\
&&\multicolumn{2}{l}{$ \ccest {e_2} \wedge \Pat(\all_2) \sqsubseteq \Pat(\all) \wedge$}\\
&&\multicolumn{2}{l}{$ \forall m \in \Cat(\all_1) : \forall \rho_m \sqsupseteq \Pat(\all):$}\\
&&&$\Upsat(m, \rho_m) = (\rho_r, \rho_e)\wedge $\\
&&&$\rho_r \sqsubseteq \rho_s \Rightarrow \rho_e \sqsubseteq \Pat(\all) \wedge$\\
&&&$\Cat(\all_2) \sqsubseteq \Phiat(m, \rho_m) \wedge $\\
&&\multicolumn{2}{l}{$\mathbf{unit} \in \Cat(\all) $}\\
{[\textit{CV-Exercise}]}&\multicolumn{3}{l}{$\ccestl {\exercise {\rho}} $ iff}\\
&&\multicolumn{2}{l}{$ \rho \sqsubseteq \rho_s \Rightarrow \rho \sqsubseteq \Pat(\all) \wedge $}\\
&&\multicolumn{2}{l}{$ \mathbf{unit} \in \Cat(\all)$}\\
\end{tabular}
\caption{Compositional Verbose part 2}
\label{tab:CompVerb2}
\end{table}

\section{Constraint generation}
\label{sec:ConstraintGen}
\newcommand{\genl}[1]{\mathcal{C}_{*\rho_s}\llbracket (#1)^\all \rrbracket}
\newcommand{\gen}[1]{\mathcal{C}_{*\rho_s}\llbracket (#1) \rrbracket}
\newcommand{\Cel}{\mathsf{C}}
\newcommand{\Rel}{\mathsf{\Gamma}}
\newcommand{\Pel}{\mathsf{P}}
\newcommand{\Mel}{\mathsf{M}}
\newcommand{\El}{\mathsf{E}}
\newcommand{\Upsel}{\mathsf{\Upsilon}}
\newcommand{\Phiel}{\mathsf{\Phi}}
\newcommand{\braces}[1]{\{ #1 \} }
\newcommand{\parens}[1]{\( #1 \) }

Now since we have an analysis that is compositional-verbose, we can design an algorithm to compute the set of constraints derived from the analysis. Then such set is given to a constraint solver algorithm to compute an estimate for the program.

\subsection{Constraints}
We now define the following elements:
\[
\begin{array}{llcl}
\mathit{Cache}      & \Cel   & : & A \rightarrow \absvalues \\
\mathit{Permission} & \Pel   & : & A \rightarrow \perms\\
\mathit{Var}        & \Rel   & : & \vars \rightarrow \absvalues \\
\mathit{State}      & \Mel   & : & \labs \times \perms \rightarrow \absvalues \\
\mathit{Stack}      & \Upsel & : & \names \times \perms \rightarrow \perms \times \perms \\
\mathit{Network}    & \Phiel & : & \names \times \perms \rightarrow \absvalues.
\end{array}
\]
This are the implementation of the elements of the environments and are maps as described above.

A constraint element named $\El$ is a pure syntactical element that represent the index of the map described above.
\[
\begin{array}{llcl}
\mathit{Cache\ element}      & \Cel(\all)       \\ %& : & \absvalues \\
\mathit{Permission\ Element} & \Pel(\all)       \\ %& : & \perms\\
\mathit{Var\ element}        & \Rel(x)          \\ %& : & \absvalues \\
\mathit{State\ element}      & \Mel(\ell, \rho) \\ %& : & \absvalues \\
\mathit{Stack\ element}      & \Upsel(a, \rho)  \\ %& : & \perms \times \perms \\
\mathit{Network\ element}    & \Phiel(a, \rho)  \\ %& : & \absvalues.
\end{array}
\]
As we can see an element is composed by the cache element to which is referred and its index.

Now let us introduce the constraints. We let $c$ range over \emph{constraints}, defined by the following productions:
\[
\begin{array}{lcrcll}
c & ::= &\{\vat\} & \sqsubseteq & \El & \mathit{Term\ inclusion}\\
& | & \El & \sqsubseteq & \El & \mathit{Element\ inclusion} \\
& | & \widehat{Op}(\vec{\El_i}) & \sqsubseteq & \El & \mathit{Operation inclusion}\\
& | & c & \Rightarrow & c & \mathit{Implication}\\
\end{array}
\]
We notice that there are no constraint specific for the three record operations $\widehat{Get}$, $\widehat{Set}$, $\widehat{Del}$, because we treat them as standard operations.
The main forms of constraints are:
\begin{itemize}
\item $\{\true\} \sqsubseteq \Cel(\all) $ that means that $\true$ must be in the possible estimate of the node marked with $\all$;
\item $\{\undef\} \sqsubseteq \Rel(x) $ that means that $\undef$ must be in the possible estimate of the $x$ variable;
\item $\Cel(\all_1) \sqsubseteq \Cel(\all) $  that means that the estimate of node $\all_1$ must be contained in the node $\all$ (as before the same are with the variables);
\item $\widehat{Op}_+(\Cel(\all_1), \Cel(\all_2))\sqsubseteq \Cel(\all)$  that means that the result of the abstract operation corresponding to $+$ with $\Cel(\all_1)$ and $\Cel(\all_2)$ as arguments must be contained in the estimate of $\Cel(\all)$;
\item $\{\true\}\sqsubseteq \Cel(\all_0) \Rightarrow \Cel(\all_1) \sqsubseteq \Cel(\all)$ that means that the fact that $\true$ is contained in the estimate of $\Cel(\all_0)$ implies that the value of $\Cel(\all_1)$ must be contained in the estimate of the node $\Cel(\all)$ (this form is used in the if construct);
\item $\{\lam {x} {\lbt 0}\}\sqsubseteq \Cel(\all_1) \Rightarrow \Cel(\all_0) \sqsubseteq \Cel(\all)$ that means that the fact that $\lam {x} {\lbt 0}$ is contained in the estimate of $\Cel(\all_1)$ implies that the value of the lambda (contained in $\Cel(\all_0)$) must be contained in the estimate of the node $\all$ (this form is used in the application);
\end{itemize}

In order to transform the $\forall$ construct of the compositional rules in our constraints (e.g., in the app expression or in the \texttt{deref} expression), since both lambdas and references are finite sets in the program, we generate one implication constraint for each element in the program in this way: let be $Ref_*$ the set of all reference labels of the program $\forall \ell \in v_1: \muat(\ell, \rho_s) \sqsubseteq \Cat(\all)$ is transformed in the set $\braces{\ell \in \Cel(\all_1) \Rightarrow \Mel(\ell, \rho_s) \sqsubseteq \Cel(\all) | \ell \in Ref_*}$.

In this way we define these finite sets:
\[
\begin{array}{l l}
Ref_* & $is the set of all references of the program;$\\
lambda_* & $is the set of all lambdas of the program;$\\
Names_* & $is the set of all names in the program;$\\
NamePerms_* & $ is the set of all permission associated with channel in the program.$\\
\end{array}
\]

\subsection{Generation}
To obtain the set of constraint the AST of the program (composed only by expression since there are no statements) is given to an algorithm that traverse it and, for each subtree of it, returns the set of constraint generated. The algorithm in tables \ref{tab:ConstGen1} and \ref{tab:ConstGen2} $\genl {e}$ explore the tree and produces the set of constraints.

As simple example the program $(((\lam {x} {x^{1}})^{2} (\lam {y} {False^{3}})^{4})^{5} True^{6})^{7}$ , ignoring the permission check, yields this set of constraints:
\[
\begin{array}{lll}
\{\\
& \{\true\} &\sqsubseteq \Cel(6),\\
& \{\false\} &\sqsubseteq \Cel(3),\\
& \{\lam {x} {x^{1}}\} &\sqsubseteq \Cel(2),\\
& \{\lam {y} {\true^{6}}\} &\sqsubseteq \Cel(4),\\
& \Rel(x) &\sqsubseteq \Cel(1),\\
& \{\lam {x} {x^{1}}\} &\sqsubseteq \Cel(2) \Rightarrow \Cel(1) \sqsubseteq \Cel(5),\\
& \{\lam {x} {x^{1}}\} &\sqsubseteq \Cel(2) \Rightarrow \Cel(4) \sqsubseteq \Rel(x),\\
& \{\lam {x} {x^{1}}\} &\sqsubseteq \Cel(5) \Rightarrow \Cel(1) \sqsubseteq \Cel(7),\\
& \{\lam {x} {x^{1}}\} &\sqsubseteq \Cel(5) \Rightarrow \Cel(6) \sqsubseteq \Rel(x),\\
& \{\lam {y} {\true^{6}}\} &\sqsubseteq \Cel(2) \Rightarrow \Cel(3) \sqsubseteq \Cel(5),\\
& \{\lam {y} {\true^{6}}\} &\sqsubseteq \Cel(2) \Rightarrow \Cel(4) \sqsubseteq \Rel(y),\\
& \{\lam {y} {\true^{6}}\} &\sqsubseteq \Cel(5) \Rightarrow \Cel(3) \sqsubseteq \Cel(7),\\
& \{\lam {y} {\true^{6}}\} &\sqsubseteq \Cel(5) \Rightarrow \Cel(6) \sqsubseteq \Rel(y)\\
\}
\end{array}
\]
\todo{expand?}

\begin{table}[htb]
\begin{tabular}{l l l l}
{[\textit{CG-Val}]} & \multicolumn{3}{l}{$ \genl {v} = \vat \sqsubseteq \Cel(\all)$} \\ 
{[\textit{CG-Var}]} & \multicolumn{3}{l}{$ \genl {x} = \Rel(x) \sqsubseteq \Cel(\all)$} \\ 
{[\textit{CG-Lambda}]} & \multicolumn{3}{l}{$ \genl {\lam{x}{\lbt 0}} = $}\\
&& \multicolumn{2}{l}{$\{\{\lam{x}{\lbt 0}\} \sqsubseteq \Cel(\all)\}\cup $}\\
&& \multicolumn{2}{l}{$ \gen {\lbt 0} $} \\
{[\textit{CG-Let}]} & \multicolumn{3}{l}{$\genl {\letexpr{x_1}{\lbt 1}{{e'}^{\all'}}} = $}\\
&& \multicolumn{2}{l}{$ \gen {\lbt 1} \cup \gen {{e'}^{\all'}} \cup$ }\\
&& \multicolumn{2}{l}{$ \{\Cel(\all_1) \sqsubseteq \Rel(x_1)\} \cup \braces{\Pel(\all_1) \sqsubseteq \Pel(\all)}) \cup $} \\
&& \multicolumn{2}{l}{$ \{\Pel(\all') \sqsubseteq \Pel(\all)\} \cup \{\Cel(\all') \sqsubseteq \Cel(\all)\} $}\\
{[\textit{CG-App}]}&\multicolumn{3}{l}{$ \genl {\appl {\lbt 1} {\lbt 2}} = $}\\
&& \multicolumn{2}{l}{$\gen {\lbt 1} \cup \gen {\lbt 2} \cup$} \\
&& \multicolumn{2}{l}{$\braces{\Pel(\all_1) \sqsubseteq \Pel(\all)} \cup \braces{\Pel(\all_2) \sqsubseteq \Pel(\all)}\cup$} \\
&& \multicolumn{2}{l}{$\{\braces t \sqsubseteq \Cel(\all_1) \Rightarrow \Cel(\all_2) \sqsubseteq \Rel(x)$}\\
&&&$| t = (\lam {x} {\lbt 0}) \in lambda_* \}\cup$\\
&& \multicolumn{2}{l}{$\{\braces t \sqsubseteq \Cel(\all_1) \Rightarrow \Cel(\all_0) \sqsubseteq \Cel(\all)$}\\
&&&$| t = (\lam {x} {\lbt 0}) \in lambda_* \}\cup$\\
&& \multicolumn{2}{l}{$\{\braces t \sqsubseteq \Cel(\all_1) \Rightarrow \Pel(\all_0) \sqsubseteq \Pel(\all)$}\\
&&&$| t = (\lam {x} {\lbt 0}) \in lambda_* \}\cup$\\
{[\textit{CG-Op}]}&\multicolumn{3}{l}{$ \genl {\op (\vec{\lbt i})} = $}\\
&&\multicolumn{2}{l}{$\bigcup_i (\gen {\lbt i} \cup \braces{\Pel(\all_i) \sqsubseteq \Pel(\all)})\cup$}\\
&&\multicolumn{2}{l}{$\braces{\widehat{op} (\Cel(\all_i)) \sqsubseteq \Cel(\all)}$}\\
{[\textit{CG-Cond}]}&\multicolumn{3}{l}{$\genl{\cond {\lbt 0} {\lbt 1} {\lbt 2}} = $}\\
&&\multicolumn{2}{l}{$ \gen {\lbt 0} \cup \gen {\lbt 1} \cup \gen {\lbt 2} \cup$}\\
&&\multicolumn{2}{l}{$\braces{\Pat(\all_0) \sqsubseteq \Pat(\all)} \cup$} \\
&&\multicolumn{2}{l}{$\braces{\widehat{\true} \in \Cel(\all_0) \Rightarrow \Cel(\all_1) \sqsubseteq \Cel(\all)}\cup$}\\
&&\multicolumn{2}{l}{$\braces{\widehat{\true} \in \Cel(\all_0) \Rightarrow \Pel(\all_1) \sqsubseteq \Pel(\all)}\cup$} \\
&&\multicolumn{2}{l}{$\braces{\widehat{\false} \in \Cel(\all_0) \Rightarrow \Cel(\all_2) \sqsubseteq \Cel(\all)}\cup$}\\
&&\multicolumn{2}{l}{$\braces{\widehat{\false} \in \Cel(\all_0) \Rightarrow \Pel(\all_2) \sqsubseteq \Pel(\all)}$} \\
{[\textit{CG-While}]}&\multicolumn{3}{l}{$\genl {\while {\lbt 1} {\lbt 2}} = $}\\
&&\multicolumn{2}{l}{$ \gen {\lbt 1} \cup \gen {\lbt 2} \cup $}\\
&&\multicolumn{2}{l}{$\braces{\Pel(\all_1) \sqsubseteq \Pel(\all)} \cup$} \\
&&\multicolumn{2}{l}{$\braces{\true \in \Cel(\all_1) \Rightarrow \Pel(\all_2) \sqsubseteq \Pel(\all) }\cup$}\\
&&\multicolumn{2}{l}{$\braces{\false \in \Cel(\all_1) \Rightarrow \widehat{\undef} \sqsubseteq \Cel(\all)}$}\\
\end{tabular}
\caption{Constraint generation part 1}
\label{tab:ConstGen1}
\end{table}

\begin{table}[htb]
\begin{tabular} {l l l l}
{[\textit{CG-GetField}]}&\multicolumn{3}{l}{$\genl {\lookup {\lbt 1} {\lbt 2}} = $}\\
&&\multicolumn{2}{l}{$ \gen {\lbt1} \cup \gen {\lbt 2} \cup$}\\
&&\multicolumn{2}{l}{$\braces{\Pel(\all_1) \sqsubseteq \Pel(\all)} \cup \braces{\Pel(\all_2) \sqsubseteq \Pel(\all)} \cup$} \\
&&\multicolumn{2}{l}{$\widehat{get} (\Cel(\all_1), \Cel(\all_2)) \sqsubseteq \Cel(\all)$} \\
{[\textit{CG-SetField}]}&\multicolumn{3}{l}{$\gen {\store {\lbt 0} {\lbt 1} {\lbt 2}} = $}\\
&&\multicolumn{2}{l}{$ \gen {\lbt 0} \cup \genl {\lbt 1} \cup \gen {\lbt 2} \cup $}\\
&&\multicolumn{2}{l}{$\braces{\Pel(\all_1) \sqsubseteq \Pel(\all)} \cup\braces{\Pel(\all_2) \sqsubseteq \Pel(\all)} \cup\braces{\Pel(\all_3) \sqsubseteq \Pel(\all)} \cup$} \\
&&\multicolumn{2}{l}{$\widehat{set} (\Cel(\all_1), \Cel(\all_2), \Cel(\all_2)) \sqsubseteq \Cel(\all)$} \\
{[\textit{CG-DelField}]}&\multicolumn{3}{l}{$\genl {\delete {\lbt 1} {\lbt 2}} = $}\\ 
&&\multicolumn{2}{l}{$ \gen {\lbt1} \cup \gen {\lbt 2} \cup$}\\
&&\multicolumn{2}{l}{$\braces{\Pel(\all_1) \sqsubseteq \Pel(\all)} \cup \braces{\Pel(\all_2) \sqsubseteq \Pel(\all)} \cup$} \\
&&\multicolumn{2}{l}{$\widehat{del} (\Cel(\all_1), \Cel(\all_2)) \sqsubseteq \Cel(\all)$}\\
{[\textit{CG-Ref}]}&\multicolumn{3}{l}{$ \genl {\newref {\ell} {\lbt 1}} = $}\\
&&\multicolumn{2}{l}{$\gen {\lbt 1} \cup\braces{\Pel(\all_1) \sqsubseteq \Pel(\all)} \cup$}\\
&&\multicolumn{2}{l}{$\braces{\Cel(\all_1) \sqsubseteq \Mel(\ell, \rho_s)} \cup \braces{\{\ell\} \sqsubseteq \Cel(\all)}$}\\
{[\textit{CG-DeRef}]}&\multicolumn{3}{l}{$\genl {\deref {\lbt 1}} = $}\\
&&\multicolumn{2}{l}{$ \gen {\lbt 1} \cup\braces{\Pel(\all_1) \sqsubseteq \Pel(\all)} \cup$}\\
&&\multicolumn{2}{l}{$\{\ell \in \Cel(\all_1) \Rightarrow \Mel(\ell, \rho_s) \sqsubseteq \Cel(\all)$} \\
&&&$|\ \ell \in Ref_*\}$\\
{[\textit{CG-SetRef}]}&\multicolumn{3}{l}{$\genl {\setref {\lbt 1} {\lbt 2}} = $}\\
&&\multicolumn{2}{l}{$ \gen {\lbt 1} \cup \gen {\lbt 2} \cup $}\\
&&\multicolumn{2}{l}{$ \braces{\Pel(\all_1) \sqsubseteq \Pel(\all)} \cup \braces{\Pel(\all_2) \sqsubseteq \Pel(\all)} \cup $}\\
&&\multicolumn{2}{l}{$\{\ell \in \Cel(\all_1) \Rightarrow \Cel(\all_2) \sqsubseteq \Mel(\ell, \rho_s)$}\\
&&&$|\ \ell \in Ref_*\}\cup$ \\
&&\multicolumn{2}{l}{$\braces{\Cel(\all_2) \sqsubseteq \Cel(\all)}$} \\
{[\textit{CG-Send}]}&\multicolumn{3}{l}{$\genl {\send {e_1} {e_2} {\rho}} = $}\\
&&\multicolumn{2}{l}{$ \gen {\lbt 1} \cup \gen {\lbt 2} \cup$}\\
&&\multicolumn{2}{l}{$ \braces{\Pel(\all_1) \sqsubseteq \Pel(\all)} \cup \braces{\Pel(\all_2) \sqsubseteq \Pel(\all)} \cup$}\\
&&\multicolumn{2}{l}{$\braces{\{\mathbf{unit}\} \sqsubseteq \Cel(\all)} \cup$}\\
&&\multicolumn{2}{l}{$ \{ \{m\} \in \Cel(\all_1) \Rightarrow \Pel(\all) \sqsubseteq \rho_m \Rightarrow \Upsel(m, \rho_m) = (\rho_r, \rho_e)$}\\
&&&$| m \in Names_*, \rho_m \in NamePerms_*\}\cup$\\
&&\multicolumn{2}{l}{$ \{ \{m\} \in \Cel(\all_1) \Rightarrow \Pel(\all) \sqsubseteq \rho_m \Rightarrow \rho_r \sqsubseteq \rho_s \Rightarrow \rho_e \sqsubseteq \Pel(\all)$}\\
&&&$| m \in Names_*, \rho_m \in NamePerms_*\}\cup$\\
&&\multicolumn{2}{l}{$ \{ \{m\} \in \Cel(\all_1) \Rightarrow \Pel(\all) \sqsubseteq \rho_m \Rightarrow \rho_r \sqsubseteq \rho_s \Rightarrow \Cel(\all_2) \sqsubseteq \Phiel(m, \rho_m)$}\\
&&&$| m \in Names_*, \rho_m \in NamePerms_*\}$\\
{[\textit{CG-Exercise}]}& \multicolumn{3}{l}{$\genl {\exercise {\rho}} $}\\
&&\multicolumn{2}{l}{$ \braces {\rho \sqsubseteq \rho_s \Rightarrow \rho \sqsubseteq \Pel(\all)} \cup $}\\
&&\multicolumn{2}{l}{$ \mathbf{unit} \in \Cel(\all)$}\\
\end{tabular}
\caption{Constraint generation part 2}
\label{tab:ConstGen2}
\end{table}

\section{Constraint solving}
\label{sec:ConstraintSolving}
To compute efficiently an analysis estimate from the constraint set we used an algorithm derived from the worklist algorithm presented in \cite{PrincipleProgramAnalysis, CMLCFA}. It has in tables \ref{tab:Worklist1} and \ref{tab:Worklist2} is shown a simplification of the algorithm that solves only constraint for data, permission and network constraint are removed for sake of readability.

The algorithm works on a graph where each constraint element $\El$ is represented by a node and each constraint (except to the term inclusion) is represented by either standard or conditional edges according to the kind of the constraint. Each node \texttt{p} contains a data field \texttt{D[p]}. The algorithm also have a worklist \texttt{W} of nodes to be processed.

Here we show which edges are generated by a constraint:
\begin{itemize}
\item $\{\true\} \sqsubseteq \El $ do not generate any edge; it insert $\true$ in \texttt{D}[$\El$] and add $\El$ in \texttt{W};
\item $\El_1 \sqsubseteq \El_2$ generates an edge from $\El_1$ to $\El_2$;
\item $\widehat{Op}(\vec{\El_i})\sqsubseteq \El$ generate an edge from each $\El_i$ to $\El$;
\item $t \sqsubseteq \El \Rightarrow \El_1 \sqsubseteq \El_2$ give rise to a conditional edge in $\El$ and in $\El_1$ both from $\El_1$ to $\El_2$;
\end{itemize}

When a conditional edge is been processed there is a check on the precondition (the part before the arrow) and if the check succeed the edge is traversed, otherwise no.

The initialization of the algorithm is done in steps 1: it just creates the structure for storing the graph and the worklist. In step 2 the graph is build as shown in the list above according to the constraint in input. Finally the graph is traversed in step 3. The traversal is done removing an element from \texttt{W} and processing all his edges. When a node is processed its data are propagated to his neighbors and in case of conditional constraint if the precondition is respected the data is propagated, otherwise no. If in a propagation the data of the destination is modified, the destination node is added to \texttt{W}.

Notice that the propagation of a value do not replace the old value with the new one, but it joins the values in a lattice. Since this the analysis is sound because the partial ordering is maintained.

When \texttt{W} is empty the system is in a fix point and step 3 terminates. In step 4 all data contained in each node of the graph is copied in the cache, environment and memory of the analysis and form an acceptable program estimate.

\begin{table}[htb]
\small
\begin{center}
\begin{tabular}{l l l}
INPUT: & $\genl {e_*}$\\
OUTPUT: & $(\Cel, \Rel, \Mel)$\\
METHOD: &
Step 1:& Initialization\\
&&
\begin{lstlisting}[mathescape]
W := [] : Queue(CElem)
D := [] : Map(CElem -> $\hat{V}$)
E := [] : Map(CElem -> Constraint)
for a in cache do 
    Add (C a, $\bot$) D
    Add (C a, []) E
for x in vars do 
    Add (R x, $\bot$) D
    Add (R x, []) E
for r in refs do 
    Add (Mu ($\bot$, $\ell$), $\bot$) D
    Add (Mu ($\bot$, $\ell$), []) E
\end{lstlisting}\\
&Step 2: & Building the graph\\
&&
\begin{lstlisting}[mathescape]
for cc in lst do
    case cc of
    | {t} $\sqsubseteq$ p  -> 
      propagate p {t}
    | p1  $\sqsubseteq$ p2 -> 
      Add cc E[p1]
    | {t} $\sqsubseteq$ p $\Rightarrow$ p1 $\sqsubseteq$ p2 -> 
      Add cc E[p]
      Add cc E[p1]
    | {t} $\sqsubseteq$ p $\Rightarrow$ {t1} $\sqsubseteq$ p2 -> 
      Add cc E[p]
    | $\widehat{op}(\vec{ps}) \sqsubseteq$ p1  -> 
      for p in ps do
        Add cc E[p]
    | $\widehat{Get}$(p1, p2) $\sqsubseteq$ p3 -> 
      Add cc E[p1]
      Add cc E[p2]
    | $\widehat{Del}$(p1, p2) $\sqsubseteq$ p3 -> 
      Add cc E[p1]
      Add cc E[p2]
    | $\widehat{Set}$(p1, p2, p3) $\sqsubseteq$ p4 -> 
      Add cc E[p1]
      Add cc E[p2]
      Add cc E[p3]
\end{lstlisting}\\
\end{tabular}
\end{center}
\caption{Worklist Algorithm part 1.}
\label{tab:Worklist1}
\end{table}
\begin{table}[htb]
\small
\begin{center}
\begin{tabular}{l l l}
&Step 3: & Iteration\\
&&
\begin{lstlisting}[mathescape]
while W $\neq$ [] do
    q = dequeue W
    for cc in E[q] do
        case cc of
        | p1  $\sqsubseteq$ p2 -> 
            propagate p2 D[p1]
        | {t} $\sqsubseteq$ p $\Rightarrow$ p1 $\sqsubseteq$ p2 -> 
            if t $\in$ D[p] then
                propagate p2 D[p1]
        | {t} $\sqsubseteq$ p $\Rightarrow$ {t1} $\sqsubseteq$ p2 ->
            if t $\in$ D[p] then
                propagate p2 {t1}
        | $\widehat{op}(\vec{ps}) \sqsubseteq$ p1  -> 
            args = [D[p] | p $\in \vec{ps}$]
            res = $\widehat{op}$ args
            propagate p1 res
        | $\widehat{Get}$(p1, p2) $\sqsubseteq$ p3 -> 
            propagate p3 
                [D[C $\alpha$] | $\alpha \in \widehat{Get}$ (D[p1], D[p2])]
        | $\widehat{Del}$(p1, p2) $\sqsubseteq$ p3 -> 
            propagate p3 $\widehat{Del}$ (D[p1], D[p2]) 
        | $\widehat{Set}$(p1, p2, p3) $\sqsubseteq$ p4 -> 
            propagate p4 $\widehat{Set}$ (D[p1], D[p2]. D[p3]) 
\end{lstlisting}\\
& Step 4: & Recording the solution\\
&&
\begin{lstlisting}[mathescape]
for $\ell$ in $Ref_*$ do $\hat{\mu}(\ell)$ = D[Mu $\ell$]
for x in $Var_*$ do $\hat{\Gamma}(x)$ = D[R x]
for $\alpha$ in $Cache_*$ do $\hat{C}(\alpha)$ = D[C $\alpha$]
\end{lstlisting}\\
USING: \\
&&
\begin{lstlisting}[mathescape]
propagate q d =
    if d $\not\sqsubseteq$ D[q] then
        D[q] = D[q] $\join$ d
        Enqueue q W
    
\end{lstlisting}\\
\end{tabular}
\end{center}
\caption{Worklist Algorithm part 2.}
\label{tab:Worklist2}
\end{table}

\section{Abstract domains choice}
\label{sec:AbstractDomChoice}
In this section we introduce all abstract domains used in the analysis. In this purpose we used the classical approach of abstract interpretations of \cite{StringAbstraction, PrincipleProgramAnalysis}. We will even show how our choice respect the assumption made in section \ref{sec:CorrectnesReqs}.

\subsection{Abstract Value}
In the implementation of the analysis an abstract value is a set containing the abstraction of each atomic domain defined in the calculus in section \ref{sec:Calculus}.

\begin{definition}[Partial order on abstract values]
Given two abstract values $\vat, \vat'$ we say that $\vat \sqsubseteq \vat'$ if $\forall \hat {u} \in \vat :\exists \hat{u'} \mid \hat{u} \sqsubseteq \hat{u'}$
\end{definition}
This means that abstract values are partially ordered according with prevalues of which they are composed.

In the following part we define all the domain abstractions.

\subsubsection{Finite domains}
As required in \ref{asm:finite} the abstraction of finite domains coincide with their concrete themselves. So, both abstraction and concretization function are just the identity function. We use this abstraction for boolean ($\true, \false$) and $\undef$ and $\unit$. The pre-order relation in this case is the simple $\subseteq$ between abstract values.

\subsubsection{Lambdas}
Since all lambdas of a program are a finite set, we abstract as finite domains.

\subsubsection{References}
Since labels $\ell$ associated to references are finite (the count is the number of $\newref \ell e$ expressions) we abstract as finite domains.

\subsubsection{Numbers}
Numbers are abstracted with sign domain as in \cite{PrincipleProgramAnalysis} with this abstraction function:
\begin{align*}
\sigma (n)=
\begin{cases}
   + & \quad\text{if}\ i>0 \\
   - & \quad\text{if}\ i<0 \\
   0 & \quad\text{if}\ i=0 \\
\end{cases}
\end{align*}
Of course an abstract values can contain more than one abstract number (e.g., $\vat = {+, 0, \dots}$ means that $\vat$ can contains positive numbers or zero, or other). 

Even in this case the pre-order relation is the $\subseteq$ between abstract values.

\subsubsection{Strings}
Since we need to track the form of the messages we need an abstraction of strings that is enough precise to perform the analysis. Aimed by this purpose we adopt, as abstraction of string values, a domain derived from the prefix notation defined in \cite{StringAbstraction}. 

A string can be either: exact or a prefix. An exact string represent itself in the concrete domain (e.g., "tag" stand for "tag") while a prefix represent all strings with them as prefix (e.g., "abc*" stand for "abc", "abcde", "abc123", but not "bdf"). Prefix strings are pre-ordered by the following relation:
\begin{align*}
\hat{S} \sqsubseteq_{\hat{PR}} \hat{T}
\begin{cases}
    exact(\hat{S}) \wedge exact(\hat{T}) \wedge \hat{T} = \hat{S} \\ 
    S = \bot_{\hat{PR}}\\
    \neg exact(\hat{T}) \wedge (\forall i \in [0, len(\hat{T}) - 1] : len(\hat{T}) \leq len(\hat{S}) \wedge \hat{T}[i] = \hat{S}[i])\\
\end{cases}
\end{align*}
We say that a string $\hat{S}$ is smaller than $\hat{T}$ if $\hat{S}$ is $\bot_{\hat{PR}}$ or if $\hat{T}$ is not exact and is a prefix of $\hat{S}$ or if both are exact strings and are equals. Where the function $exact$ states if a string is exact.
Notice that and $\top_{\hat{PR}} = "*"$.

The $\join$ operation between two abstract strings is an prefix strings containing the longest common prefix between them.

An abstract string represent or itself if it is exact, or all the strings that starts with it. This grants the prerequisites given in \ref{sec:CorrectnesReqs}.

\subsubsection{Records}
Records are abstracted using a field sensitive approach since the analysis must track them with high precision. The abstraction of a record $r$ is a map $\hat{r}$ from abstract strings to abstract values. In order to maintain simplicity in the implementation, an abstract record contains various exact field, but just one prefix field with value $\top$ where all prefix strings are collapsed. This can seem weird, but do not alter the soundness of the analysis; moreover we found that in real JavaScript code accessing a record with a string that is computed, and not literal, is a rare practice. This helps a lot with the $\widehat{Set}$ operation.

Abstract records has this property: \\
let be $r = \rec{\vec{str_i: v_i}}$ and $\hat{r}=\rec{\vec{\widehat{str_j}: \widehat{v_j}}}$. $\sigma(r) = \hat{r}$ if all the following conditions hold true: 
\begin{itemize}
\item $\forall i: \exists j \mid \sigma(str_i) \sqsubseteq str_j$;
\item $\forall i: \exists j \mid \sigma(str_i) \sqsubseteq \widehat{str_j} \Rightarrow \sigma(v_i) \sqsubseteq \vat_j.$
\end{itemize}

This means that the abstraction of a record must contain an abstract field bigger than the abstraction of the concrete field, and the value associated with it is greater than the abstraction of the concrete value. For example $\sigma(\{a: 12\})$ can be $\{a: +\}$, but even $\{a: \{+, \false\}\}$, and $\{a: +, b: \true\}$, but not $\{b: \true\}$. 

Note that $\sigma(\{\}) = any\ record$ because since the empty record has no field, all possible abstract record contains all its field.

To collect more information on records we state the $\join$ as the union of the two maps.

\subsection{Abstract operations} %- specifica delle operazioni astratte
\label{sec:AbstractOp}
In this section we present the main abstract operations of the abstract domains.

\subsubsection{Numbers}
The arithmetic operation on sign domain are the following:
\begin{align*}
\begin{tabular}{ | c | *{5}{c}|}
  \hline                       
  $\bar{-}$ & + & 0 & - & $\top$ & $\bot$ \\
  \hline
   & - & 0 & + & $\top$ & $\bot$ \\
  \hline  
\end{tabular}
\qquad 
\begin{tabular}{ | c | *{4}{c}|}
  \hline                       
  $\bar{+}$ & + & 0 & - & $\top$ \\
  \hline
   + & + & + & $\top$ & $\top$\\
   0 & + & 0 & - & $\top$\\
   - & $\top$ & - & - & $\top$\\
   $\top$ & $\top$ & $\top$ & $\top$ & $\top$\\
  \hline  
\end{tabular}
\end{align*}

\begin{align*}
\begin{tabular}{ | c | *{4}{c}|}
  \hline                       
  $\bar{*}$ & + & 0 & - & $\top$ \\
  \hline
   + & + & 0 & - & $\top$\\
   0 & 0 & 0 & 0 & 0\\
   - & - & 0 & + & $\top$\\
   $\top$ & $\top$ & 0 & $\top$ & $\top$\\
  \hline  
\end{tabular}
\qquad 
\begin{tabular}{ | c | *{5}{c}|}
  \hline                       
  $\bar{/}$ & + & 0 & - & $\top$ & $\bot$\\
  \hline
   + & + & 0 & - & $\top$ & $\bot$ \\
   0 & $\bot$ & $\bot$ & $\bot$ & $\bot$ & $\bot$ \\
   - & - & 0 & + & $\top$ & $\bot$ \\
   $\top$ & $\top$ & 0 & $\top$ & $\top$ & $\bot$ \\
   $\bot$ & $\bot$ & $\bot$ & $\bot$ & $\bot$ & $\bot$ \\
  \hline  
\end{tabular}
\end{align*}

\subsubsection{Strings}
String operation are interesting, especially the \texttt{concat} function.
\begin{align*}
concat(\widehat{str_1}, \widehat{str_2}) = \widehat{str_1}\\
\end{align*}
It simply return the first string as a prefix. Indeed, the concatenation of two strings are for definition contained in the abstraction of the first followed by any character.

Another important function on string is the comparison operation $\widehat{==}$
\newcommand{\strat}{\widehat{str}}
\begin{align*}
\strat_1 \widehat{==} \strat_2
\begin{cases}
\true & \quad\text{if}\ exact(\strat_1) \wedge exact(\strat_2) \wedge \strat_1 == \strat_2\\
\false & \quad\text{if}\ exact(\strat_1) \wedge exact(\strat_2) \wedge \strat_1 \neq \strat_2\\
\top_b & \quad\text{if}\ exact(\strat_1) \wedge \neg exact(\strat_2) \wedge \strat_1 \sqsubseteq \strat_2\\
\false & \quad\text{if}\ exact(\strat_1) \wedge \neg exact(\strat_2) \wedge \strat_1 \not\sqsubseteq \strat_2\\
\top_b & \quad\text{if}\ \neg exact(\strat_1) \wedge exact(\strat_2) \wedge \strat_2 \sqsubseteq \strat_1\\
\false & \quad\text{if}\ \neg exact(\strat_1) \wedge exact(\strat_2) \wedge \strat_2 \not\sqsubseteq \strat_1\\
\top_b & \quad\text{if}\ \neg exact(\strat_1) \wedge exact(\strat_2) \wedge \strat_1 \sqsubseteq \strat_2 \vee \strat_2 \sqsubseteq \strat_1\\
\false & \quad\text{if}\ \neg exact(\strat_1) \wedge exact(\strat_2) \wedge \strat_1 \not\sqsubseteq \strat_2 \vee \strat_2 \not\sqsubseteq \strat_1
\end{cases}
\end{align*}
We finally say that a string $\strat_1$ is compatible with $\strat_2$ if $\true \in (\strat_1 \widehat{==} \strat_2)$.

\subsubsection{Records}
Record operations are three: $\widehat{Get}, \widehat{Set}, \widehat{Del}$.

Get operation returns the join of all the values contained by all fields compatible with a string.
\begin{align*}
\widehat{Get}(\rec{\strat_i: \vat_i}, \strat) = \undef \join (\bigsqcup\{\vat_i \mid \strat \sqsubseteq \strat_i\})
\end{align*}
We notice that $\undef$ is added to the result. This is required since an abstract record can contains more field of the concrete one. Moreover we have to remember that two concrete strings can have an abstract representation that can be compatible.

Set operation adds the value in the corresponding field or adds a property with the value. Its abstract corresponding function it adds the value to all the compatible fields.

\begin{align*}
\widehat{Set}&(\{\vec{\strat_i: \vat_i}\}, \strat, \vat) = \\
&
\begin{cases}
\{\vec{\strat_i: \vat_i}, \strat_j: \vat_j\join\vat\} & \quad\text{if}\ exact(\strat) \wedge \exists j \mid exact(\strat_i) \wedge \strat == \strat_j\\
\{\vec{\strat_i: \vat_i}, \strat_{\top}: \vat_{\top} \join \vat\} & \quad\text{if}\ \neg exact(\strat)\\
\{\vec{\strat_i: \vat_i}, \strat: \vat\} & \quad\text{otherwise}\\
\end{cases}
\end{align*}

Del operation removes a field from an object. Its abstract representation has to remove a field from a record, but abstracted records can contain more field than the concrete ones, hence the $\widehat{Del}$ return the same object in input.
\begin{align*}
\widehat{Del}(\rec{\strat_i: \vat_i}, \strat) = \rec{\strat_i: \vat_i}
\end{align*}

%\section{Requirements verification} % verifica delle condizioni (anche semi-formale)
%\label{sec:RequirementVerif}

\section{Implementation-specific details}
\label{sec:ImplSpecDetails}
In our implementation we had to deal with specific problems. One of them were about abstract records because since the program is able to add or modify at run-time both field and values of a record, we had to change the representationof it. Indeed, records cannot contain values because the constraint o