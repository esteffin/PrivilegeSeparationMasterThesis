\section{Chrome extension architecture}
\label{sec:ExtDetails}
As showed in \cite{ChromeExtensionOnline} a Chrome Extension is an archive containing files of various kind like JavaScript, HTML, JSON, images and others that extends the browser features.

A basic extension contains a manifest file and one or more Javascript or Html files.

\subsection{Manifest}
The manifest file \texttt{manifest.json} is a JSON-formatted file containing the specification of the extension. It is the entry point of the extension and contains two mandatory fields: \texttt{name} and \texttt{version} respectively containing the name and the version of the extension. Other important fields are:
\begin{itemize}
\item \texttt{background}: contains an object with either \texttt{script} or \texttt{page} field. The former contains the source of the content script, while the other the source of an HTML page. If is used the \texttt{script} field, the scripts are injected in a empty extension core page, while if it is used \texttt{page} the HTML document with all his elements (e.g., scripts) composes the extension core;
\item \texttt{content\_scripts}: contains a list of content script objects. Each object contains the field \texttt{matches}, a list of match patterns (Match patterns are explained below), and a field \texttt{js} containing the list of Javascript source files to be injected;
\item \texttt{permissions}: contains a list of privileges that are requested by the extension. These can be either a host match pattern for XHR request or the name of the API needed.
\end{itemize}

Another possible field is \texttt{optional\_permissions}. It contains the list of optional permissions that the extension could require. It is used to restrict the privileges granted to the app. To use one of this permissions the background page has to explicitly require it and, after having used it, the permission has to be released. A program using the optional permissions can reduce the possible privileges escalated by an attacker.

A match pattern is a string composed of three parts: \texttt{scheme}, \texttt{host} and \texttt{path}. Each part can contain a value, or \texttt{"*"} that means all possible values. In table \ref{tab:URLPatSyn} is shown the syntax of the URL patterns; more details are reported in \cite{ChromeExtensionMatch}. In this way we can decide to inject some content scripts only on pages derived from a given match. This is used when a content script of the extension has to interact with only certain pages. For example \texttt{"*://*/*"} means all pages; \texttt{"https://*/*"} means all HTTPS pages; \texttt{"https://*.google.com/*"} means all HTTPS domains that are subdomains of google with all their possible path (e.g., \texttt{mail.google.com}, \texttt{www.google.com}, \texttt{docs.google.com/mine/index.html}).

\begin{table}[tlb]
\begin{verbatim}
<url-pattern> := <scheme>://<host><path>
<scheme> := '*' | 'http' | 'https' | 'file' | 'ftp' | 'chrome-extension'
<host> := '*' | '*.' <any char except '/' and '*'>+
<path> := '/' <any chars>
\end{verbatim}
\caption{Url pattern syntax. Table taken from \cite{ChromeExtensionMatch}}
\label{tab:URLPatSyn}
\end{table}

In table \ref{src:AManifest} we can see a manifest of a simple Chrome extension that expands the feature of moodle. We can see that the extension has an empty background page on which is injected the file \texttt{background.js}. It also has permissions tabs and download, and can execute XHR to all path contained in \texttt{https://moodle.dsi.unive.it/}. It has also one content script that is injected in all subpages of \texttt{https://moodle.dsi.unive.it/}.
\begin{table}[tlb]
\lstset{language=java,showstringspaces=false}
\begin{small}
\begin{lstlisting}
{
	"manifest_version": 2,
	"name":"Moodle expander",
	"description":"Download homework and uploads marks from a JSON string",
	"version":"1",
	"background": { "scripts": ["background.js"] },
	"permissions":  
		[
			"tabs",
			"downloads",
			"https://moodle.dsi.unive.it/*"
		],
	"content_scripts": 
		[
			{
				"matches": ["https://moodle.dsi.unive.it/*"],
				"js": ["myscript.js"]
			}
		]
}
\end{lstlisting}
\end{small}
\caption{A manifest file}
\label{src:AManifest}
\end{table}

\subsection{Content scripts}
Content scripts are Javascript source files that are automatically injected to the web page if this matches with the pattern defined in the manifest. Otherwise it can be programmatically injected by a background page using the \texttt{chrome.tabs.executeScript} call (the function require \texttt{tabs} permission). In the example of table \ref{tab:URLPatSyn} the Javascript file \texttt{myscript.js} is injected to all sub-pages of \texttt{https://moodle.dsi.unive.it/}. In the extension framework content scripts are designed to interact with pages. Since this interaction could be the entry point for an attacker, content scripts have no permissions except the one used to communicate with the extension core. In order to reduce injection of code in the content script from a malign page, there is a strong isolation between the heaps of these two. Content scripts of the same extension are run together in their own address space, and the only way they have to interact with the page on which they are injected is via the DOM API. DOM API lets the content scripts to access and modify only standard fields of the DOM object, while other changes are kept locally\cite{ChromeExtSpec}. This strong isolation mitigate the risk of code injection since it blocks almost completely pointer exchange. 
\missingfigure{Figura dell'articolo della Felt su isolated world.}

In order to keep functionality of extensions, communication between content scripts and extension core is done using a message passing interface. The message passing interface has crucial importance in this work since it is the only way for a content script to trigger execution of a privilege. We will discuss it later in \ref{subs:MPI}.

\subsection{Extension core}
The extension core is the most critical part of the application. It is executed in a unique origin like \texttt{chrome-extension://hcdmlbjlcojpbbinplfgbjodclfijhce} in order to prevent cross origin attacks, but can communicate with all origins that match with one of the host permission defined in the manifest. In this environment are executed all scripts defined in the background field of the manifest. Since background pages can have remote object, they can also request to the web such resources, but this can be very dangerous. In fact if the resources are on simple HTTP connections these can be altered by an attacker. In \cite{ChromeExtSpecSnd} is described how to enforce the security policy in order to avoid such possible weakness. Background pages can interact with content scripts via message passing.
\missingfigure{Maybe figura schema Chrome Extensions comm \& elements.}

\subsection{Message passing API}
\label{subs:MPI}
Every content script of the extension can access \texttt{chrome.runtime} object that contains the implementation of the message passing interface \cite{ChromeExtensionRuntime}. 

The main way to send a message to the extension core is invoking the method \texttt{chrome.runtime.sendMessage}. Like all Chrome APIs even the message passing is asynchronous. As primary arguments it takes the message that can be of any kind and a callback function that is triggered if someone answer to the message. Before sending, the message is marshaled using a JSON serializer. This prevents exchange of pointers or of functions, but limits the expressiveness of the prototype-based object-oriented feature of Javascript. It also fails in presence of recursive objects.

In order to listen to inbound messages, a component has to register a function on the \texttt{chrome.runtime.onMessage} event. This function will be triggered when a message arrives. Its arguments are the message (unmarshalled by the API), the sender and an optional callback used to send response to the sender of the message. The sender field is very important because is the only way to know the real identity of the sender. In fact the message may not be used to decide the sender, because it can be of every kind.

Since content scripts are multiple and injected in various pages (tabs), the extension core for sending a message has to use the \texttt{sendMessage} method of the \texttt{tab} object to which the message has to be sent. Its behavior is the same of the \texttt{chrome.runtime.sendMessage} method.

In table \ref{tab:MPIMessage} we can see how to use the simple message passing interface. In it a component simply sends the message and wait for a response. The other registers \texttt{onMessage} function in the event listener \texttt{onMessage}. When the handler is triggered by an incoming message \texttt{onMessage} function checks the message and decides to compute something according to the request or refuses the message doing nothing.

Another way to communicate, that is more secure, is using channels as in table \ref{tab:MPIPort}. In the message passing API there is a method called \texttt{connect} that triggers the corresponding event listener \texttt{onConnect} is triggered and returns a port. It has as optional arguments the name of the channel that is creating. A port object is a bidirectional channel that can be used to communicate. It contains the methods \texttt{postMessage}, \texttt{disconnect} and the events \texttt{onMessage} and \texttt{onDisconnect}. Communication using ports instead of the classical \texttt{chrome.runtime.sendMessage} is more secure, because only who has one of the port endpoint can communicate. Obviously ports are not serializable, so it is impossible to leak the ownership of a port. Ports grant the sender of the message.

\lstset{language=java,showstringspaces=false}
\begin{table}[tlb]
\begin{small}
\begin{center}
\begin{tabular}{p{0.45\linewidth} | p{0.45\linewidth}}
Sender & Receiver\\
\hline
\begin{lstlisting} 
var info = "hello";
var callback = 
	function(response) 
	{ 
		console.log("get response: " + response);
	};
chrome.runtime.sendMessage(info, callback);
\end{lstlisting}&
\begin{lstlisting} 
var onMessage = 
	function(message, sender, sendResponse) 
	{ 
		if (message = "hello") 
		{
		    //compute message
			sendResponse("hi");
		}
		else 
			console.log("connection refused from"+sender);
	};
chrome.runtime.onMessage.addListener(onMessage);
\end{lstlisting}\\
\end{tabular}
\end{center}
\end{small}
\caption{Sending a message.}
\label{tab:MPIMessage}
\end{table}

\begin{table}
\begin{small}
\begin{center}
\begin{tabular}{p{0.45\linewidth} | p{0.45\linewidth}}
Port opening active & Port opening passive\\
\hline
\begin{lstlisting} 
var port = chrome.runtime.connect({name: "cs1"});
port.onMessage.addListener(onMessage)
port.postMessage("hi")
\end{lstlisting}&
\begin{lstlisting} 
var scriptPort = null;
var onConnect = 
	function(port) 
	{ 
		if (port.name = "cs1") 
		{
			scriptPort = port;
			port.onMessage.addListener(onMessage);
		} 
		else 
		{
			console.log("connection refused"); 
			port.disconnect();
		}
	};
chrome.runtime.onConnect.addListener(onConnect)
\end{lstlisting}\\
\end{tabular}
\end{center}
\end{small}
\caption{Port creation.}
\label{tab:MPIPort}
\end{table}

\section{Bundling}
\label{sec:Bundling} 
\todo{scriviere molto bene questa parte}
\todo[inline]{esempio; }
As seen in table \ref{tab:MPIMessage} the choice taken by a component when a message is received can depend on various factors decided by the programmer.

Let us explain the example in \ref{tab:Bundled}: suppose to have three components Background, CS1 and CS2. CS1 can only send messages that has \texttt{"getPasswd"} as title and CS2 only \texttt{"executeXHR"}. Here the Background deduct the sender checking the title of the messages instead of of explicitly checking the argument \texttt{sender}. According to the check decides which privilege has to be executed. This practice is called bundling and is very dangerous because an attacker can compromise just one of the two content scripts and from that one can forge messages with any form escalating a permission that it does not have in the original setting.

To avoid such weakness is important to check the sender field of the \texttt{onMessage} function in order to be sure of the sender. This cannot be enough because, as discussed before, contents script that are injected on the same page share their memory, tab and origin, and the message passing interface are does not distinguish them. The fix of this weakness is to use ports instead of the \texttt{chrome.runtime.sendMessage} function in order to have different listener for each content script. In table \ref{tab:UnBundled} is showed an unbundled code.

\begin{table}[tlb]
\begin{small}
\begin{center}
\begin{tabular}{p{0.95\linewidth}}
Background\\
\hline
\begin{lstlisting}
function onMessage(message, sender, response)
{    	
	switch (message.title) {
		/* Requests from content script 1 */
		case "getPasswd":
		// get passwords
		response(passwd)
		break;
		
		/* Requests from content script 2 */
		case "executeXHR":
		var host = message.host
		var m = message.content;
		// execute XHR on args
		break;
				
		default:
		throw "Invalid request from contentScript";
	}
}
\end{lstlisting}\\
\hline
\hline
Content script CS1 \\
\hline
\begin{lstlisting}
var mess = {title: "getPasswd"};
chrome.runtime.sendMessage(mess);
\end{lstlisting}\\
\hline
\hline
Content script CS2\\
\hline
\begin{lstlisting}
var mess = {title: "executeXHR", host: "www.google.com", content: "hi there"};
chrome.runtime.sendMessage(mess);
\end{lstlisting}\\
\end{tabular}
\end{center}
\end{small}
\caption{Bundled code.}
\label{tab:Bundled}
\end{table}
\begin{table}[tlb]
\begin{small}
\begin{center}
\begin{tabular}{p{0.95\linewidth}}
Unbundling checking sender\\
\hline
\begin{lstlisting}
function onMessage(message, sender, response)
{    	
	switch (sender) {
		/* Requests from content script 1 */
		case CS1:
		// get passwords
		response(passwd)
		break;
		
		/* Requests from content script 2 */
		case CS2:
		var host = message.host
		var m = message.content;
		// execute XHR on args
		break;
				
		default:
		throw "Invalid request from contentScript";
	}
}
\end{lstlisting}\\
\hline
\hline
Unbundling using ports.\\
\hline
\begin{lstlisting}
// Handler for messages from CS1
function onMessage_cs1(message, sender, response)
{    	
	/* Requests is content script 1 since it is on its port */
	// get passwords
	response(passwd)
}
// Handler for messages from CS2
function onMessage_cs2(message, sender, response)
{    	
	/* Requests is content script 2 since it is on its port */
	var host = message.host
	var m = message.content;
	// execute XHR on args
}
port_cs1.onMessage.addListener(onMessage_cs1);
port_cs2.onMessage.addListener(onMessage_cs2);
\end{lstlisting}\\
\hline
\end{tabular}
\end{center}
\end{small}
\caption{Two unbundled code.}
\label{tab:UnBundled}
\end{table}

\section{Flow logic}
\label{sec:FlowLogic}
Flow logic, introduced in \cite{FlowLogic}, is a static analysis approach that derive from state of the art in program verification and has been successfully used in research projects \cite{CarmelFlowLogic,CarmelFlowLogicFormalization}. It has its root in classical approaches of static program analysis \cite{PrincipleProgramAnalysis} like control flow analysis \cite{CMLCFA}, abstract interpretation, constraint based analysis and data flow analysis. Flow logic lets the specification to focus on when an analysis estimate is acceptable, instead of how to compute such estimate. Another property is that, like structural operational semantic, is adaptable to lots of programming paradigms. Finally it can be used with various levels of abstraction according to the implementation details that are needed, but can be easily translated from one level to another. 

The principal levels of abstraction are grouped in some possible approaches: abstract versus compositional and succinct versus verbose. The abstract style is more closer to standard semantic while the compositional one is more syntax directed. The succinct approach is similar to the typical style of type systems because it focuses the top part of the analysis, while the verbose approach traces all the internal information in cashes and are typical of the implementation of control flow analysis and constraint based analysis.

%Usually the formal analysis is done starting an abstract-succinct specification stating when an estimate is acceptable. Such specification is turned in a compositional-verbose analysis and from this is possible to design an algorithm that expresses all acceptability relation of a program in a set of classic logical constraints. Finally the set of constraint, and an abstract representation of the concrete values, are given to a worklist algorithm that computes an acceptable estimate for the program. This is the way followed by our analysis.

The modularity fits very well for analysis, because the abstract succinct style is very clean and expressive without dealing with implementation details, and from such specification is easy to commute it to a compositional verbose specification. From the latter is possible to build an algorithm for generating the set of constraints of a program and combining it with a simple constraint solver like the worklist algorithm \cite{PrincipleProgramAnalysis} or with a more sophisticated ones like the succinct solver \cite{SuccinctSolver} or the BANSHEE solver \cite{BansheeSolver}, is possible to compute the estimate for a program. \todo{quale dei due?}

In this work, indeed, is used the flow logic, and as described before, the various specification-to-implementation steps are done\todo{traballante...}. In chapter \ref{chap:Formalization} is used an abstract-succinct approach, and in chapter \ref{chap:Implementation} the analysis is expanded in the compositional-verbose one; from this the algorithm for constraint-generation is built and finally is used a worklist algorithm to solve the constraints and to find an estimate for a program. 